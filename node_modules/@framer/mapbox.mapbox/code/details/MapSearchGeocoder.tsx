import * as React from "react"
import Geocoder from "react-map-gl-geocoder"
import { InteractiveMap, InteractiveMapProps, Marker } from "react-map-gl"
import * as MapSearch from "./MapSearch"
import { LOCAL_LANGUAGE } from "./Constants"
import { MapLocation } from "./MapTypes"
import getPin from "./Pin"

interface GeocoderResult {
  bbox?: [number, number, number, number]
  center: [number, number]
  geometry: GeoJSON.Point
  id?: string
  language?: string
  placeholder?: string
  place_name: string
  place_type: string[]
  text?: string
  type: "Feature"
  localResult?: boolean
}

export interface Props extends MapSearch.Props {
  mapRef: React.RefObject<InteractiveMap>
  onViewportChange: InteractiveMapProps["onViewportChange"]
  mapboxApiAccessToken: string
  locations?: MapLocation[]
}

interface State {
  searchResult: GeocoderResult
}

export class MapSearchGeocoder extends React.Component<Props, State> {

  // Workaround for missing top-center position
  containerNodeRef = React.createRef<HTMLDivElement>()
  geocoderRef = React.createRef<any>()

  state: State = {
    searchResult: null
  }

  onClear() {
    this.setState(_prevState => ({ searchResult: null }))

    // Changing the state of the component causes it to be redrawn
    // and neither to input nor the cachedResult is cleared on clear.
    // Without this workaround the result would be a reappearing or
    // not disappearing text in the geocoder search input.
    if (this.geocoderRef.current) {
      this.geocoderRef.current.cachedResult = ""
      const innerGeocoder = this.geocoderRef.current.getGeocoder()
      if (innerGeocoder) {
        innerGeocoder.setInput("")
      }
    }
  }

  onResult({ result }: { result: GeocoderResult }) {
    this.setState({ searchResult: result })
  }

  _hackSearchInputPosition() {
    if (this.geocoderRef.current && this.geocoderRef.current.geocoder && this.geocoderRef.current.geocoder.container) {
      this.geocoderRef.current.geocoder.container.style.marginTop = `${this.props.offset}px`
    }
  }

  componentDidMount() {
    this._hackSearchInputPosition()
  }

  componentDidUpdate() {
    this._hackSearchInputPosition()
  }

  render() {
    const { mapRef,
      onViewportChange,
      mapboxApiAccessToken,
      limitSearch,
      language,
      placeholder,
      position,
      dropSearchPin,
      pin,
      locations,
    } = this.props

    const { searchResult } = this.state
    const Pin = getPin(pin)

    const bbox = getMapviewBbox(mapRef, limitSearch);

    // WORKAROUND Framer does not like empty string as option
    const languageWithEmptyStrForLocal = language == LOCAL_LANGUAGE ? "" : language

    const localGeocoder = getLocalGeocoder(locations)

    // Workaround for missing top-center position
    const containerNode = getContainerNode(this.containerNodeRef, position)

    return (
      <React.Fragment>
        {containerNode}
        <Geocoder
          ref={this.geocoderRef}
          mapRef={mapRef}
          onViewportChange={onViewportChange}
          mapboxApiAccessToken={mapboxApiAccessToken}
          containerRef={this.containerNodeRef}
          bbox={bbox}
          language={languageWithEmptyStrForLocal}
          placeholder={placeholder}
          localGeocoder={localGeocoder}
          filter={localGeocoder ? getLocalGeocoderResults : null}
          position={containerNode ? null : position}
          onClear={() => this.onClear()}
          onResult={(event: any) => this.onResult(event)}
        />
        {searchResult && dropSearchPin && (
          <Pin
            longitude={searchResult.center[0]}
            latitude={searchResult.center[1]}
          />
        )}
      </React.Fragment>
    )
  }
}

function getLocalGeocoderResults(feature: GeocoderResult): boolean {
  return feature.localResult
}

function getLocalGeocoder(locations: MapLocation[]) {
  if (locations && locations.length) {
    return (query: any): GeocoderResult[] => {
      const features = locations
        .filter((location) => {
          if (location.name.toLowerCase().search(query.toLowerCase()) !== -1) {
            return true;
          }
          if (!location.category) {
            return false;
          }
          return location.category.toLowerCase().search(query.toLowerCase()) !== -1;
        })
        .map((location) => {
          // Map locations to https://github.com/mapbox/carmen/blob/master/carmen-geojson.md
          const feature: GeocoderResult = {
            localResult: true, // Workaround to ease filtering local results
            type: "Feature",
            center: [
              location.location.longitude,
              location.location.latitude,
            ],
            geometry: {
              coordinates: [
                location.location.longitude,
                location.location.latitude,
              ],
              type: "Point"
            },
            place_name: location.name,
            place_type: ["place"],
          }
          return feature
        })
      return features
    }
  }

  return null
}

function getMapviewBbox(mapRef: React.RefObject<InteractiveMap>, limitSearch: boolean) {
  if (mapRef == null || mapRef.current == null) {
    return null
  }

  const mapviewBounds = mapRef.current.getMap().getBounds();
  const mapviewBoundsArray = mapviewBounds.toArray();
  const mapviewBbox: [number, number, number, number] = [mapviewBoundsArray[0][0], mapviewBoundsArray[0][1], mapviewBoundsArray[1][0], mapviewBoundsArray[1][1]];
  const bbox: [number, number, number, number] | null = limitSearch ? mapviewBbox : null;
  return bbox;
}

// This a workaround for the mapboxgl.Map to support the top-center position string
function getContainerNode(containerNodeRef: React.RefObject<HTMLDivElement>, positionName: MapSearch.Props["position"]): React.ReactNode {
  const isContainerNodeNeeded = positionName == "top-center"

  if (!isContainerNodeNeeded) {
    return null
  }

  return (
    <TopCenterContainer ref={containerNodeRef} />
  )
}

// This a workaround for the mapboxgl.Map to support the top-center position string
const TopCenterContainer = React.forwardRef((props: {}, ref: React.RefObject<HTMLDivElement>) => {

  const topCenterContainerStyle: React.CSSProperties = {
    pointerEvents: "none",
    zIndex: 2,
    position: "relative",
    display: "flex",
    justifyContent: "center",
    alignContent: "center",
  }

  const position = "top-center"

  return (
    <div
      style={topCenterContainerStyle}
      ref={ref}
      className={`mapboxgl-ctrl-${position}`}
    />
  )
})
