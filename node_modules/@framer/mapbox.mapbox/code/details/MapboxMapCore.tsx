import { PropertyControls, ControlType } from "framer";
import ReactMapGL, { InteractiveMap, ViewState } from "react-map-gl";
import * as React from "react";
import { Component } from "react";

import { Defaults, Styles } from "./Constants";
import { MapViewportCoordinates, MapLocation } from "./MapTypes";
import { transformRequest } from "./TransformRequest";
import produce from "immer";
import { MapSearchGeocoder } from "./MapSearchGeocoder";
import { LocationHash } from "./LocationHash"
import { GetAccessTokenWatermark } from "./GetAccessTokenWatermark";

export interface Props extends MapViewportCoordinates {
  accessTokenURL: string;
  accessToken?: string;

  anonymousStyle: string; // style chosen from main list
  authenticatedStyle: string; // style chosen from authenticated list
  userStyle: string; // style url entered manually

  showLocationText: boolean;
  locations?: any[] // FIXME different types for locations in SequentialLocationMap and MapSearchGeocoder
  children?: React.ReactNode;
  showSearch?: boolean
}

export interface State {
  viewport: MapViewportCoordinates;
}

///
/// MapboxMapCore is a simple Framer X wrapper around a map.
/// Use it inside other components as an interactive map and expose its controls in the Framer X UI.
/// For examples, see CityLocationMap and CustomLocationMap.
///
export class MapboxMapCore extends Component<Props, State> {
  // Controls used by FramerX to provide a nice UI
  static propertyControls: PropertyControls<Props> = {
    accessTokenURL: {
      type: ControlType.String,
      title: "Get AccessToken",
      placeholder: "from your Mapbox account",
      hidden(props) {
        return !!props.accessToken;
      }
    },
    accessToken: { type: ControlType.String, title: "AccessToken" },
    anonymousStyle: {
      type: ControlType.Enum,
      options: Styles.core.options,
      optionTitles: Styles.core.titles,
      title: "Map Style",
      hidden(props) {
        return !!props.accessToken;
      }
    },
    authenticatedStyle: {
      type: ControlType.Enum,
      options: Styles.core.options.concat(Styles.designer.options).concat(Styles.custom),
      optionTitles: Styles.core.titles.concat(Styles.designer.titles).concat(Styles.custom),
      title: "Map Style",
      hidden(props) {
        return !props.accessToken;
      }
    },
    userStyle: {
      type: ControlType.String,
      title: " ",
      placeholder: "mapbox://styles/<youraccountID>/<mapstyleID>",
      hidden(props) {
        return props.authenticatedStyle !== Styles.custom;
      }
    },
    showLocationText: {
      type: ControlType.Boolean,
      title: "Show location text"
    },
  };

  static defaultProps: Props = {
    width: 375,
    height: 375,
    longitude: 0,
    latitude: 0,
    zoom: 0,
    bearing: 0,
    pitch: 0,
    anonymousStyle: Styles.default,
    authenticatedStyle: Styles.default,
    userStyle: "",
    accessTokenURL: "https://account.mapbox.com/access-tokens/?pluginName=FramerX",
    showLocationText: false,
  };

  constructor(props: Props) {
    super(props);
    const { accessToken, accessTokenURL, anonymousStyle, authenticatedStyle, userStyle, ...viewport } = this.props;
    this.state = {
      viewport
    };
  }

  mapRef = React.createRef<InteractiveMap>()

  // Was an instance of ViewState set as a value for this.state.viewport
  // it would remove width and height from this.state.viewport
  // FIXME Is there a better way to handle this?
  _updateViewport(opts: Partial<MapViewportCoordinates>) {
    const viewport = produce(this.state.viewport, (draft) => {
      Object.assign(draft, opts);
    })
    this.setState({ viewport })
  }

  // Interactive use of ReactMapGL relies on state, so we manage the flow of those changes here.
  componentDidUpdate(pp: Props) {
    const viewportProperties: Array<keyof MapViewportCoordinates> = ["width", "height", "latitude", "longitude", "zoom", "bearing", "pitch"];

    const changed = viewportProperties.reduce((collection, key) => {
      if (pp[key] !== this.props[key]) {
        collection[key] = this.props[key];
      }
      return collection;
    }, {} as Partial<MapViewportCoordinates>);
    if (Object.keys(changed).length > 0) {
      this._updateViewport(changed)
    }
  }

  activeStyle() {
    const { accessToken, anonymousStyle, authenticatedStyle, userStyle } = this.props;
    if (!!accessToken) {
      // authenticated
      if (authenticatedStyle === Styles.custom) {
        return userStyle || Styles.default;
      }
      return authenticatedStyle || Styles.default;
    }
    // not authenticated
    return anonymousStyle || Styles.default;
  }

  render() {
    const {
      accessToken,
      anonymousStyle,
      authenticatedStyle,
      userStyle,
      children,
      showLocationText,
      showSearch,
      ...rest
    } = this.props;
    const { viewport } = this.state;

    let mapStyle = this.activeStyle();

    const mapboxApiAccessToken = accessToken || Defaults.accessToken

    return (
      <div style={{ position: "relative" }}>
        <ReactMapGL
          ref={this.mapRef}
          mapboxApiAccessToken={mapboxApiAccessToken}
          transformRequest={transformRequest}
          onViewportChange={(vp) => this._updateViewport(vp)}
          mapStyle={mapStyle}
          {...rest}
          {...viewport} // ensure viewport is after the rest parameters to avoid being overwritten
        >
          {!accessToken && <GetAccessTokenWatermark />}
          {showSearch && <MapSearchGeocoder
            {...rest}
            mapRef={this.mapRef}
            onViewportChange={(vp: ViewState) => this._updateViewport(vp)}
            mapboxApiAccessToken={mapboxApiAccessToken}
          />}
          {children}
          {showLocationText && <LocationHash {...viewport} />}
        </ReactMapGL>
      </div>
    );
  }
}
